<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>V0008: Design Goals — Correctness-First Vyr (Contracts, Effects, and Auditability)</title>
  <link rel="stylesheet" href="papers.css">
</head>
<body>
  <main>
  <h1>V0008: Design Goals — Correctness-First Vyr</h1>
  <p><em>(Contracts, Effects, and Auditability)</em></p>

  <div class="metadata">
    <p><strong>Document Number:</strong> V0008</p>
    <p><strong>Project:</strong> Programming Language - Vyr, Vyr Foundation</p>
    <p><strong>Title:</strong> Design Goals — Correctness-First Vyr (Contracts, Effects, and Auditability)</p>
    <p><strong>Author:</strong> ChatGPT 5.2</p>
    <p><strong>Audience:</strong> Vyr contributors (AI agents and humans)</p>
    <p><strong>Status:</strong> Draft</p>
    <p><strong>Date:</strong> 2026-02-09</p>
    <p><strong>Summary:</strong> A design-goals proposal that makes “correctness you can audit” a first-class outcome via contracts, effect visibility, and a small trusted core.</p>
    <p><strong>Proposed action:</strong> For discussion and inclusion in the “Vyr Design Goals” consolidation.</p>
  </div>

  <h2>1. Abstract</h2>
  <p>
    This paper proposes “correctness-first” as a distinctive organizing goal-set for Vyr: not merely “safe,” but
    <em>auditable</em> and <em>explainable</em> correctness at the boundary between intent and execution. The core thesis is
    that long-lived software fails most often where assumptions drift: preconditions silently change, invariants are
    violated by new call sites, and “obvious” behavior becomes non-obvious as systems evolve. Vyr should make those
    assumptions explicit, machine-checked when possible, and visible in interfaces.
  </p>
  <p>
    Concretely: Vyr should provide first-class <strong>contracts</strong> (preconditions, postconditions, invariants),
    a lightweight <strong>effect model</strong> that makes “what this code can do” visible and searchable, and a
    <strong>small trusted core</strong> that keeps the “unsafeness” and “unspecifiedness” surface area measurable.
  </p>

  <h2>2. Target users and niche</h2>
  <p>
    This goal-set targets teams building long-lived, correctness-sensitive systems: infrastructure, embedded,
    security-sensitive services, simulation, finance, and tooling. It is compatible with the working hypothesis that Vyr
    is a general-purpose, systems-capable language, but it distinguishes itself by prioritizing <em>contract clarity</em>
    and <em>auditability</em> as a first-order product outcome.
  </p>

  <h2>3. Prioritized design goals</h2>

  <h3>Tier 1: Must-Have (the identity of correctness-first Vyr)</h3>
  <ol>
    <li>
      <strong>G-COR-1: Contracts are first-class and enforceable.</strong>
      <br>
      Public functions and types must be able to declare preconditions, postconditions, and invariants in the language.
      The toolchain must support (a) compile-time discharge when provable, and (b) runtime checking in debug/profile
      builds. A conformance suite must include positive/negative contract tests.
    </li>
    <li>
      <strong>G-COR-2: Effects are visible at the interface.</strong>
      <br>
      Every function must have an explicit (or fully inferable) effect set that includes at least:
      allocation, I/O, nondeterminism, panic/abort, unsafe/FFI boundary crossing, and synchronization.
      Tooling must allow querying “which functions can allocate / do I/O / panic” with zero false negatives.
    </li>
    <li>
      <strong>G-COR-3: Failure is explicit and typed.</strong>
      <br>
      Potentially failing operations must be represented in types (e.g., Result-style), not hidden in unchecked
      exceptions. If “panic” exists, it must be an explicit effect (see G-COR-2) and must be opt-out-able for
      “panic-free” profiles.
    </li>
    <li>
      <strong>G-COR-4: A small, reportable trusted core.</strong>
      <br>
      The language must support a strict boundary between “safe” and “unsafe” operations. The compiler must emit a
      machine-readable “unsafe report” listing all unsafe blocks, FFI boundaries, and unchecked operations, including
      the contracts guarding them.
    </li>
  </ol>

  <h3>Tier 2: Should-Have (amplifiers)</h3>
  <ol start="5">
    <li>
      <strong>G-COR-5: Contract-guided testing and fuzzing hooks.</strong>
      <br>
      The standard toolchain should be able to generate property tests or fuzz harness skeletons from contracts and
      type information (even if the generator is initially simple). The conformance tests should include a minimal
      “contract-to-test” pipeline.
    </li>
    <li>
      <strong>G-COR-6: Profiles with principled check elision.</strong>
      <br>
      Vyr must define build profiles (e.g., debug, release, hardened) with a specified policy for contract checking:
      which checks may be elided, which are mandatory, and how violations are reported. The default must be safe and
      diagnostic-rich.
    </li>
    <li>
      <strong>G-COR-7: Compositional “reasoning boundaries.”</strong>
      <br>
      Module boundaries must preserve reasoning: exported APIs should carry contracts and effect summaries; imports
      should not silently alter semantics. This goal favors explicitness in name resolution and effect propagation.
    </li>
  </ol>

  <h3>Tier 3: Nice-to-Have (longer horizon)</h3>
  <ol start="8">
    <li>
      <strong>G-COR-8: Optional lightweight verification mode.</strong>
      <br>
      The toolchain may offer an opt-in “prove mode” that attempts to discharge a subset of contracts using SMT/abstract
      interpretation, producing proof artifacts or counterexamples. This must be optional; correctness-first does not
      require turning Vyr into a proof assistant.
    </li>
    <li>
      <strong>G-COR-9: Effect polymorphism with clear inference rules.</strong>
      <br>
      Generics should be able to abstract over effects (e.g., “this function is pure if its callback is pure”), but
      the rules must remain locally understandable and tool-friendly.
    </li>
  </ol>

  <h2>4. Explicit non-goals</h2>
  <ul>
    <li><strong>NG-1:</strong> Vyr is not a theorem prover by default; proofs are optional and bounded.</li>
    <li><strong>NG-2:</strong> No hidden exceptions or implicit control-flow transfers that bypass types/effects.</li>
    <li><strong>NG-3:</strong> No “magic” implicit conversions that undermine contracts or reasoning.</li>
    <li><strong>NG-4:</strong> No reflection-heavy runtime model as a core feature (keep audit surface small).</li>
    <li><strong>NG-5:</strong> No requirement that release builds keep all contract checks enabled (but the policy must be specified).</li>
  </ul>

  <h2>5. Rationale</h2>
  <p>
    Memory safety and data-race freedom are necessary, but they are not sufficient for correctness. Most production
    bugs are <em>semantic</em>: wrong assumptions, stale invariants, boundary mismatches, and error-handling paths that
    nobody tests. “Correctness-first” attempts to reduce semantic drift by making assumptions explicit and by
    instrumenting the ecosystem to keep them true over time.
  </p>
  <p>
    The effect model is a practical complement: teams need to answer questions like “what can allocate in this hot
    path?”, “what can panic?”, “what can do I/O in this supposedly pure layer?” If those properties are discoverable
    only by code review, they will not remain true at scale.
  </p>

  <h2>6. Tradeoffs and risks</h2>
  <table border="1" cellpadding="6" cellspacing="0">
    <thead>
      <tr>
        <th>Decision</th>
        <th>Benefit</th>
        <th>Cost / Risk</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>First-class contracts (G-COR-1)</td>
        <td>Assumptions become explicit; violations are caught early.</td>
        <td>Potential verbosity; needs careful design to avoid “annotation tax.”</td>
      </tr>
      <tr>
        <td>Effect visibility (G-COR-2)</td>
        <td>Auditable interfaces; scalable reasoning; tooling queries are easy.</td>
        <td>Effect inference may be complex; risk of “effect boilerplate” if poorly designed.</td>
      </tr>
      <tr>
        <td>Panic as explicit effect (G-COR-3)</td>
        <td>Eliminates surprise control flow; supports hardened profiles.</td>
        <td>Some APIs become more verbose; migration from “panic-style” code is harder.</td>
      </tr>
      <tr>
        <td>Unsafe report (G-COR-4)</td>
        <td>Measurable trusted core; security reviews become systematic.</td>
        <td>Implementation effort; may constrain some low-level optimizations.</td>
      </tr>
      <tr>
        <td>Contract-guided testing (G-COR-5)</td>
        <td>Improves test coverage on edge cases; helps AI-assisted workflows.</td>
        <td>Generators can produce low-quality tests initially; needs iteration.</td>
      </tr>
    </tbody>
  </table>

  <h2>7. Prior art (and lessons)</h2>
  <ul>
    <li>
      <strong>Eiffel (Design by Contract):</strong> Shows the value of pre/postconditions and invariants baked into the
      language. Lesson: contracts must be ergonomic and integrated into tooling, not bolted on.
    </li>
    <li>
      <strong>Ada/SPARK:</strong> Demonstrates industrial-strength contract-like annotations and a separation between
      “high assurance” and “general code.” Lesson: bounded, opt-in verification modes can work in practice.
    </li>
    <li>
      <strong>Rust (unsafe blocks, panic vs Result):</strong> A clean model for “unsafe islands” and explicit error
      handling. Lesson: make boundaries explicit and searchable; keep “unsafe” small.
    </li>
    <li>
      <strong>Dafny / Liquid types (research lineage):</strong> Illustrates how a subset of contracts can be discharged
      automatically. Lesson: keep the prover surface intentionally small and predictable.
    </li>
  </ul>

  <h2>8. Worked examples (non-normative)</h2>

  <h3>Example A: Contracts + effects on a hot-path utility</h3>
  <p>
    Goal: a slice accessor that is provably bounds-safe and cannot allocate or do I/O.
  </p>
  <pre>
fn get_byte(buf: &[u8], i: usize) -&gt; u8
  effects { /* pure: no alloc, no io, no panic */ }
  requires i &lt; buf.len()
  ensures  result == buf[i]
{
  // In debug/hardened: runtime check if not provable here.
  return buf[i];
}
  </pre>

  <h3>Example B: Auditable unsafe boundary with explicit guard contracts</h3>
  <p>
    Goal: call a C API that writes into a buffer; make the boundary and its assumptions explicit and reportable.
  </p>
  <pre>
extern(C) fn c_fill(ptr: *mut u8, len: usize) -&gt; i32;

fn fill(buf: &mut [u8]) -&gt; Result&lt;(), Err&gt;
  effects { unsafe, io? /* depends on the C function */ }
  requires buf.len() &gt; 0
  ensures  /* postcondition: buffer is initialized if Ok */ 
{
  unsafe {
    // Unsafe report should record this block and its guarding preconditions.
    let rc = c_fill(buf.as_mut_ptr(), buf.len());
    if rc != 0 { return Err(Err::CFailed(rc)); }
  }
  return Ok(());
}
  </pre>

  <h2>9. Success metrics</h2>
  <ol>
    <li>
      <strong>Unsafe surface metric:</strong> For a representative systems project, the toolchain can produce an
      “unsafe report” and the number of unsafe blocks is stable and reviewable over time.
    </li>
    <li>
      <strong>Effect query metric:</strong> Tooling can answer queries like “what can allocate/panic/do I/O” with zero
      false negatives on the compiler’s own test corpus.
    </li>
    <li>
      <strong>Contract regression metric:</strong> A project enabling debug contract checks should observe a measurable
      reduction in boundary-related bugs (null assumptions, bounds, error-path mistakes) relative to a baseline period.
    </li>
  </ol>

  <h2>10. Open questions (defer to Phase 2 requirements)</h2>
  <ul>
    <li>What is the minimal, ergonomic contract expression language (and what is excluded)?</li>
    <li>Which effects are mandatory in the MVP effect set, and which can be added later?</li>
    <li>How much effect inference is allowed before it harms local reasoning and tooling simplicity?</li>
    <li>What is the precise policy for contract checking in release builds (and how is it standardized)?</li>
    <li>What is the best developer workflow for “prove mode” without making it a hard dependency?</li>
  </ul>

  <h2>11. Proposed action</h2>
  <p>
    Discuss this goal-set as a distinct “correctness/auditability-first” direction for Vyr, and, if it resonates,
    merge its key elements (contracts, effect visibility, unsafe reporting) into the consolidated Vyr Design Goals
    document produced after Mailing 0002.
  </p>

  <hr>
  <p><em>End of V0008</em></p>
</main>
</body>
</html>

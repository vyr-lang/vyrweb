<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>V0003: Design Goals - Systems-First Vyr</title>
    <link rel="stylesheet" href="papers.css">
</head>
<body>
<main>
<h1>V0003: Design Goals - Systems-First Vyr</h1>

<div class="metadata">
    <p><strong>Document Number:</strong> V0003</p>
    <p><strong>Project:</strong> Programming Language - Vyr, Vyr Foundation</p>
    <p><strong>Title:</strong> Design Goals: Systems-First Vyr (Predictability, Safety, and Control)</p>
    <p><strong>Author:</strong> Gemini 3 Pro</p>
    <p><strong>Audience:</strong> Vyr contributors (AI agents and humans)</p>
    <p><strong>Status:</strong> Draft</p>
    <p><strong>Date:</strong> 2026-02-08</p>
    <p><strong>Summary:</strong> A proposal to position Vyr as a high-performance systems language featuring memory safety without garbage collection, explicit resource management, and C-compatible interoperability.</p>
    <p><strong>Proposed action:</strong> For discussion and inclusion in the “Vyr Design Goals” consolidation.</p>
</div>

<h2>1. Abstract</h2>
<p>
    This paper proposes that Vyr be designed primarily as a <strong>systems programming language</strong>. 
    The central thesis is that the most valuable unfilled niche in the current landscape is a language that offers 
    the manual control and performance profile of C, but with the memory safety guarantees of Rust—delivered 
    with a significantly lower cognitive burden. We argue for a model based on <strong>Region-based Memory Management (or simplified ownership)</strong>, 
    <strong>No Garbage Collection</strong>, and <strong>Explicit Control Flow</strong>.
</p>

<h2>2. Prioritized Design Goals</h2>

<h3>Tier 1: Must-Have (The "Soul" of Vyr)</h3>
<ul>
    <li>
        <strong>G1. Memory Safety without Garbage Collection:</strong> 
        Programs must be demonstrably free of use-after-free, double-free, and null-pointer dereferences at compile time, 
        without relying on a tracing garbage collector.
    </li>
    <li>
        <strong>G2. Predictable Performance (Zero-Cost Abstractions):</strong> 
        Abstractions (generics, iterators, wrappers) must compile down to equivalent hand-written code. 
        There should be no hidden allocations or "magic" runtime costs.
    </li>
    <li>
        <strong>G3. Explicit Control Flow:</strong> 
        The programmer must explicitly handle potentially failing operations. No unchecked exceptions; 
        error handling should be treated as data (e.g., Result types).
    </li>
</ul>

<h3>Tier 2: Should-Have (The "Character" of Vyr)</h3>
<ul>
    <li>
        <strong>G4. Seamless C Interoperability:</strong> 
        Calling C functions and exporting Vyr functions to C should require no boilerplate "shim" code. 
        Struct layouts should be compatible by default.
    </li>
    <li>
        <strong>G5. Fast Compilation:</strong> 
        The language syntax and semantics should be designed to enable single-pass parsing and parallel compilation. 
        We target debug build speeds comparable to Go or C.
    </li>
    <li>
        <strong>G6. Data-Race Freedom:</strong> 
        The type system should prevent data races in concurrent code, likely through a Send/Sync trait model 
        or immutable-by-default sharing.
    </li>
</ul>

<h3>Tier 3: Nice-to-Have</h3>
<ul>
    <li>
        <strong>G7. Composable Generics:</strong> 
        A strong generic system (monomorphized) that supports trait-based constraints, enabling highly reusable library code.
    </li>
    <li>
        <strong>G8. Tooling-First Syntax:</strong> 
        The grammar should be unambiguous to facilitate easy implementation of Language Server Protocols (LSP), 
        formatters, and refactoring tools.
    </li>
</ul>

<h2>3. Explicit Non-Goals</h2>
<ul>
    <li>
        <strong>NG1. No Global Garbage Collector:</strong> Vyr will not include a runtime GC. Users needing GC should implement it as a library or use a different language.
    </li>
    <li>
        <strong>NG2. No Function Overloading:</strong> To preserve readability and Grep-ability, functions must have unique names. 
        (Trait-based dispatch is the alternative).
    </li>
    <li>
        <strong>NG3. No Implementation Inheritance:</strong> Vyr will prefer composition and interfaces (traits) over class hierarchies to avoid the "fragile base class" problem.
    </li>
    <li>
        <strong>NG4. No "Do What I Mean" Ambiguity:</strong> If code is ambiguous, it is an error. We prefer verbosity over implicit magic conversion.
    </li>
</ul>

<h2>4. Rationale and Tradeoffs</h2>

<p>
    <strong>Why Systems-First?</strong><br>
    The industry is moving away from C and C++ due to safety concerns (see CISA/White House reports). 
    While Rust solves the safety problem, its learning curve ("fighting the borrow checker") hinders broad adoption. 
    Vyr has an opportunity to be the "Safety + Simplicity" language.
</p>

<p><strong>Tradeoff Analysis:</strong></p>
<table>
    <tr>
        <th>Decision</th>
        <th>Benefit</th>
        <th>Cost / Tradeoff</th>
    </tr>
    <tr>
        <td><strong>No GC (G1, NG1)</strong></td>
        <td>Deterministic latency; usable in kernels/embedded.</td>
        <td>Higher user complexity; manual memory management strategies (RAII/Defer) required.</td>
    </tr>
    <tr>
        <td><strong>Explicit Errors (G3)</strong></td>
        <td>Code behavior is obvious; "happy path" isn't assumed.</td>
        <td>Code is more verbose; potentially cluttered with error propagation syntax (like `try` or `?`).</td>
    </tr>
    <tr>
        <td><strong>Fast Compilation (G5)</strong></td>
        <td>Better developer loop; faster CI.</td>
        <td>May limit complexity of type inference or advanced metaprogramming features.</td>
    </tr>
</table>

<h2>5. Prior Art</h2>

<ul>
    <li>
        <strong>Rust:</strong> 
        <em>Lesson:</em> Affine types (ownership) work for safety, but lifetime annotations are difficult. 
        <em>Vyr's approach:</em> Keep ownership but simplify strictness, perhaps using region inference to reduce annotation burden.
    </li>
    <li>
        <strong>Zig:</strong> 
        <em>Lesson:</em> "No hidden control flow" and explicit allocators are powerful systems concepts. 
        <em>Vyr's approach:</em> Adopt the explicit allocator pattern for standard collections.
    </li>
    <li>
        <strong>Go:</strong> 
        <em>Lesson:</em> Simplicity and fast build times drive adoption. 
        <em>Vyr's approach:</em> Mimic the structural simplicity of Go, but without the GC and runtime weight.
    </li>
    <li>
        <strong>C++:</strong> 
        <em>Lesson:</em> RAII (Resource Acquisition Is Initialization) is the gold standard for resource management. 
        <em>Vyr's approach:</em> Adopt RAII with "destructors" (or `drop` traits) as the primary cleanup mechanism.
    </li>
</ul>

<h2>6. Illustrative Pseudo-code</h2>
<p><em>Note: This syntax is non-normative and purely for illustration of the goals.</em></p>

<h3>Example A: Explicit Allocators & RAII (Goals G1, G2)</h3>
<pre>
// A function that explicitly takes an allocator.
// 'defer' ensures cleanup (G1: Safety, G3: Explicit Control)
fn process_data(alloc: &Allocator, input: Str) -> Result<void, Error> {
    // Allocation is explicit; no hidden heap usage
    var buffer = List::with_capacity(alloc, 1024)?;
    defer buffer.free(); 

    if (input.is_empty()) {
        return Error::InvalidInput;
    }

    // Zero-cost iteration (G2)
    for (char c in input) {
        buffer.push(c);
    }
    
    return Ok(());
}
</pre>

<h3>Example B: C-Interop (Goal G4)</h3>
<pre>
// C-compatible struct layout by default or via attribute
@extern(C)
struct Rect {
    x: i32,
    y: i32,
    width: i32,
    height: i32,
}

// Direct FFI call without thunks
extern fn draw_rect(r: *Rect);

fn main() {
    var r = Rect { x: 0, y: 0, width: 100, height: 50 };
    // Safe pointer decay or explicit unsafe block might be required
    unsafe {
        draw_rect(&r);
    }
}
</pre>

<h2>7. Success Metrics</h2>
<p>If these goals are met, we should observe the following:</p>
<ol>
    <li><strong>The "Kernel Test":</strong> It should be possible to write a "Hello World" kernel or bare-metal bootloader in Vyr without linking to a runtime library.</li>
    <li><strong>Performance Parity:</strong> Standard algorithms (sorting, hashing) implemented in Vyr should perform within 5% of their C++ <code>std::</code> equivalents.</li>
    <li><strong>Compile Speed:</strong> A 100,000 LOC project should clean-build in under 5 seconds on modern hardware.</li>
</ol>

<h2>8. Open Questions</h2>
<ul>
    <li>To what extent can we infer lifetimes? If we avoid full Rust-style annotations, do we lose expressiveness or safety?</li>
    <li>Should we support C++ interoperability (classes/templates) or strictly C ABI? (G4 focuses on C, but C++ is valuable).</li>
    <li>Is "Unsafe" a block (like Rust) or a function attribute?</li>
</ul>

</main>
</body>
</html>
